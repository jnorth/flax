# Megalith

An implementation of ideas from Flux and Redux, with a class-based API.

## Overview

Megalith has the same three core concepts as Redux:

- State is stored in a single object tree.
- You mark your intent to change state by dispatching actions. Actions are
  simple objects with a `type` and optionally some parameters.
- Given an action and the previous state, a new state tree is generated using a
  simple function.

The implementation differs however, with actions being created automatically,
and state being organized into a tree of `Store` classes.

You start off by extending the Megalith Store and setting the inital state:

```js
import { Store } from 'megalith';

class Application extends Store {
  initialState = {
    count: 0,
  };
}

const app = new Application();
app.state.count; // => 0
```

Next you would create action methods that describe how to change the state:

```js
import { Store, action } from 'megalith';

class Application extends Store {
  ...

  @action increment() {
    return { ...this.state, count:this.state.count + 1 };
  }
}

const app = new Application();
app.increment();
app.state.count; // => 1
```

Behind the scenes, an action is created of type `increment`, dispatched to the
`Application` store, and the new state is generated by the `@action increment`
method we wrote. This means we can keep track of any actions, and re-play them
back:

```js
const app1 = new Application();
const app2 = new Application();
const actions = [];

app1.subscribe(event => actions.push(event.action));
app1.increment();

actions.forEach(action => app2.dispatch(action));
app2.state.count; // => 1
```

If we like, we can save the complete application state from each event as a
powerful debug tool, or even an easy undo/redo feature.

```js
const history = [];
const app = new Application();
app.subscribe(event => history.push(app.serialize()));
app.increment();

history; // => [{ count:0 }, { count:1 }]
```

## Usage

### `megalith.Store`

A base class for your store objects.

#### `megalith.Store.serialize()`

Get the entire state tree, including child stores, as a regular JS object.

#### `megalith.Store.subscribe(callback)`

Listen for action events on the store. The callback function is passed an event
object with the following properties:

`store` — The `megalith.Store` object the event was fired from.

`action` — The action that was triggered.

`before` — The store's state before the action.

`after` — The store's state after the action.

#### `megalith.Store.dispatch(action)`

Manually trigger actions. Although you typically trigger actions by calling
`@action` methods directly, this is useful for re-playing previously created
actions.

### `megalith.action`

A decorator to mark methods as action handlers. When calling these methods, an
action will be created and dispatched, creating a new state tree with the result
of the method.
